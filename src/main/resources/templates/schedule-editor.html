<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>シフトグリッド調整</title>
    <style>
        :root {
            color-scheme: light;
        }
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            font-family: "Segoe UI", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
            background-color: #f4f6f8;
        }
        .page {
            max-width: 1600px;
            margin: 0 auto;
            padding: 24px;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            color: #2563eb;
            text-decoration: none;
            margin-bottom: 12px;
        }
        .back-link:hover { text-decoration: underline; }
        .builder-hero {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 20px;
        }
        .eyebrow {
            text-transform: uppercase;
            letter-spacing: 0.12em;
            font-size: 12px;
            color: #94a3b8;
            margin: 0;
        }

        .hero-summary {
            width: 100%;
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 16px;
            padding: 18px;
            background: linear-gradient(145deg, #f8fafc, #fff);
        }

        .hero-summary-header {
            margin-bottom: 12px;
        }

        .hero-summary-header h2 {
            margin: 4px 0 6px;
            font-size: 22px;
            color: #1f2933;
        }

        .hero-summary-header p:not(.eyebrow) {
            margin: 0;
            color: #4c566a;
            font-size: 14px;
        }

        .hero-status {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
        }

        .hero-status-pill {
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 13px;
            font-weight: 600;
            background: rgba(37, 99, 235, 0.12);
            color: #1d4ed8;
        }

        .hero-status-pill.idle { background: rgba(15, 118, 110, 0.12); color: #0f766e; }
        .hero-status-pill.processing { background: #fef3c7; color: #b45309; }
        .hero-status-pill.success { background: #dcfce7; color: #14532d; }
        .hero-status-pill.error { background: #fee2e2; color: #7f1d1d; }

        .hero-metrics {
            display: grid;
            grid-template-columns: repeat(2, minmax(120px, 1fr));
            gap: 12px;
        }

        .hero-metric {
            padding: 12px 14px;
            border-radius: 12px;
            background: #fff;
            border: 1px solid rgba(148, 163, 184, 0.25);
        }

        .hero-metric span {
            font-size: 12px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .hero-metric strong {
            display: block;
            font-size: 22px;
            margin-top: 6px;
        }

        .hero-note {
            margin-top: 10px;
            font-size: 13px;
            color: #4c566a;
        }

        .builder-generation .section-subtitle {
            color: #4c566a;
            margin: 0;
        }

        .builder-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            border-radius: 12px;
            background: #f8fafc;
            margin-top: 12px;
        }

        .builder-period-picker {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
        }

        .builder-period-picker .period-inputs {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .builder-period-picker label {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 12px;
            color: #94a3b8;
        }

        .builder-period-picker input,
        .builder-period-picker select {
            font-size: 15px;
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid #d0d5dd;
            min-width: 88px;
        }

        .builder-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: flex-end;
        }

        .builder-message {
            margin-top: 12px;
            padding: 10px 12px;
            border-radius: 10px;
            font-size: 13px;
            display: none;
        }

        .builder-message.info { background: #dbeafe; color: #1d4ed8; display: block; }
        .builder-message.success { background: #dcfce7; color: #166534; display: block; }
        .builder-message.error { background: #fee2e2; color: #b91c1c; display: block; }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .info-card {
            padding: 16px 18px;
            border-radius: 14px;
            background: linear-gradient(145deg, #f8fafc, #ffffff);
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .info-label {
            font-size: 13px;
            color: #94a3b8;
            margin-bottom: 6px;
        }

        .info-value {
            font-size: 24px;
            font-weight: 700;
        }

        .shortage-panel {
            border-radius: 12px;
            border: 1px solid #fee2e2;
            background: #fff5f5;
            padding: 16px;
            margin-top: 16px;
        }

        .shortage-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .shortage-panel table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .shortage-panel th {
            text-align: left;
            padding: 6px;
            border-bottom: 1px solid rgba(248, 113, 113, 0.4);
            color: #7f1d1d;
        }

        .shortage-panel td {
            padding: 6px;
            border-bottom: 1px solid rgba(248, 113, 113, 0.2);
        }

        .table-container {
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
            background: #fff;
        }

        .table-container.small {
            max-height: 280px;
            overflow-y: auto;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        header h1 {
            font-size: 22px;
            margin: 0;
            color: #1f2933;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 16px;
        }
        .controls label {
            font-size: 12px;
            color: #4c566a;
            display: block;
            margin-bottom: 4px;
        }
        .controls input,
        .controls select {
            padding: 8px 10px;
            border: 1px solid #d0d5dd;
            border-radius: 6px;
            font-size: 14px;
            min-width: 120px;
        }
        .btn {
            border: none;
            border-radius: 6px;
            padding: 10px 18px;
            font-size: 14px;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .btn-primary {
            background-color: #2563eb;
            color: #fff;
        }
        .btn-secondary {
            background-color: #e4e7ec;
            color: #1f2933;
        }
        .btn-secondary.ghost {
            background-color: #fff;
            color: #2563eb;
            border: 1px dashed #93c5fd;
        }
        .header-links {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .btn-danger {
            background-color: #dc2626;
            color: #fff;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .layout {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 16px;
        }
        .grid-panel,
        .editor-panel {
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(15, 23, 42, 0.08);
            padding: 16px;
        }
        .grid-wrapper {
            overflow-x: auto;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            min-width: 900px;
        }
        th, td {
            border: 1px solid #e5e7eb;
            min-width: 140px;
            vertical-align: top;
        }
        th {
            background-color: #f8fafc;
            font-weight: 600;
            font-size: 13px;
            padding: 10px;
            color: #1f2933;
        }
        td {
            padding: 6px;
            background-color: #fff;
        }
        .employee-cell {
            font-weight: 600;
            background-color: #f3f4f6;
            position: sticky;
            left: 0;
            z-index: 2;
            min-width: 160px;
        }
        .grid-cell {
            min-height: 88px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            background-image: linear-gradient(180deg, rgba(15,23,42,0.02), rgba(15,23,42,0.02));
        }
        .grid-cell.active {
            outline: 2px solid #2563eb;
            outline-offset: -1px;
        }
        .grid-cell.dirty {
            background-color: #fff9db;
        }
        .shift-card {
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 12px;
            background-color: #e0f2fe;
            color: #0f172a;
            cursor: grab;
            border: 1px solid #bae6fd;
            user-select: none;
        }
        .shift-card.free {
            background-color: #fef3c7;
            border-color: #fde68a;
        }
        .shift-card.off {
            background-color: #fee2e2;
            border-color: #fecaca;
        }
        .shift-card.selected {
            box-shadow: 0 0 0 2px #2563eb inset;
        }
        .shift-card.dirty {
            border-style: dashed;
            border-color: #f97316;
        }
        .editor-panel h2 {
            font-size: 16px;
            margin-top: 0;
            color: #111827;
        }
        .form-group {
            margin-bottom: 12px;
        }
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #d0d5dd;
            border-radius: 6px;
            font-size: 14px;
        }
        .field-hint {
            font-size: 12px;
            color: #64748b;
            margin-top: 4px;
        }
        .chip-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .chip-row label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 13px;
            color: #334155;
        }
        .break-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 8px;
        }
        .break-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .break-row select {
            width: 120px;
            padding: 6px 8px;
        }
        .break-row input[type="time"] {
            width: 120px;
        }
        .chip-row--flags {
            flex-wrap: nowrap;
            width: 100%;
            justify-content: space-between;
        }
        .chip-row--flags label {
            flex: 1 1 0;
            min-width: 0;
            justify-content: center;
        }
        .chip-row--split {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }
        .chip-row--break button {
            grid-column: 1 / -1;
            width: 100%;
        }
        .persist-actions {
            padding-top: 12px;
            border-top: 1px solid #e5e7eb;
            justify-content: flex-end;
            gap: 12px;
        }
        .status-bar {
            margin-top: 12px;
            font-size: 13px;
            color: #475569;
        }
        .message {
            margin-top: 8px;
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
            display: none;
        }
        .message.show {
            display: block;
        }
        .message.success {
            background-color: #ecfdf5;
            color: #065f46;
        }
        .message.error {
            background-color: #fef2f2;
            color: #b91c1c;
        }
        @media (max-width: 1100px) {
            .layout {
                grid-template-columns: 1fr;
            }
            .employee-cell {
                position: static;
            }
        }
    </style>
</head>
<body>
    <div class="page">
        <div style="display:flex; gap:12px; flex-wrap:wrap;">
            <a class="back-link" href="/dashboard">← ダッシュボードへ戻る</a>
            <a class="back-link" href="/quick-access">← シフト運用ポータルへ戻る</a>
        </div>
        <header>
            <div>
                <h1>シフト自動生成 / グリッド調整</h1>
                <p style="margin:4px 0 0;color:#4c566a;">シフト生成欄から生成を行い、下部のグリッドで担当者ごとのシフトを細かく調整できます。</p>
            </div>
            <div class="header-links">
                <a class="btn btn-secondary ghost" href="/calendar">カレンダー表示</a>
            </div>
        </header>

        <section class="card builder-hero">
            <div class="hero-summary">
                <div class="hero-summary-header">
                    <p class="eyebrow">Builder</p>
                    <h2>対象月のシフト概要</h2>
                    <p>対象期間のシフト件数・従業員数・不足状況をひと目で確認できます。</p>
                </div>
                <div class="hero-status">
                    <span class="hero-status-pill idle" id="builder-status-pill">待機中</span>
                    <small id="builder-status-text">生成の準備が整いました</small>
                </div>
                <div class="hero-metrics">
                    <div class="hero-metric">
                        <span>対象期間</span>
                        <strong id="builder-period">-</strong>
                    </div>
                    <div class="hero-metric">
                        <span>シフト数</span>
                        <strong id="builder-assignment-count">0</strong>
                    </div>
                    <div class="hero-metric">
                        <span>従業員</span>
                        <strong id="builder-employee-count">0</strong>
                    </div>
                    <div class="hero-metric">
                        <span>不足</span>
                        <strong id="builder-shortage-count">0</strong>
                    </div>
                </div>
                <div class="hero-note" id="builder-shortage-note">不足データはありません。</div>
            </div>
        </section>

        <section class="card builder-generation">
            <div class="section-header">
                <div>
                    <h2>シフト生成</h2>
                    <p class="section-subtitle">対象月のシフトを、需要データから自動生成します。シフトの初期化や最新データの反映も、このパネルからまとめて操作できます。</p>
                </div>
            </div>
            <div class="builder-toolbar">
                <div class="builder-period-picker">
                    <button class="btn btn-secondary ghost" type="button" id="builder-prev-month">前月</button>
                    <div class="period-inputs">
                        <label>
                            <span>年</span>
                            <input type="number" id="builder-year" min="2000" max="2100">
                        </label>
                        <label>
                            <span>月</span>
                            <select id="builder-month"></select>
                        </label>
                        <label>
                            <span>粒度</span>
                            <select id="builder-granularity">
                                <option value="60" selected>60分</option>
                                <option value="30">30分</option>
                                <option value="15">15分</option>
                            </select>
                        </label>
                    </div>
                    <button class="btn btn-secondary ghost" type="button" id="builder-next-month">翌月</button>
                </div>
                <div class="builder-actions">
                    <button class="btn btn-secondary ghost" type="button" id="builder-download-csv">シフトCSVダウンロード</button>
                    <button class="btn btn-secondary" type="button" id="builder-refresh-secondary">最新シフトを読み込む</button>
                    <button class="btn btn-danger" type="button" id="builder-reset">当月のシフトをすべて削除</button>
                    <button class="btn btn-primary" type="button" id="builder-generate">シフトを生成</button>
                </div>
            </div>
            <div id="builder-message" class="builder-message"></div>
            <div class="info-grid">
                <div class="info-card">
                    <div class="info-label">シフト件数</div>
                    <div class="info-value" id="builder-info-assignments">0</div>
                </div>
                <div class="info-card">
                    <div class="info-label">従業員数</div>
                    <div class="info-value" id="builder-info-employees">0</div>
                </div>
                <div class="info-card">
                    <div class="info-label">稼働日数</div>
                    <div class="info-value" id="builder-info-days">0</div>
                </div>
            </div>
            <div class="shortage-panel" id="builder-shortage-panel" style="display:none;">
                <div class="shortage-header">
                    <strong>割当不足と空き（待機）の状況</strong>
                    <button class="btn btn-secondary ghost" type="button" id="builder-hide-shortage">閉じる</button>
                </div>
                <div class="table-container small">
                    <table>
                        <thead>
                            <tr>
                                <th>日付</th>
                                <th>シフト</th>
                                <th>割当</th>
                                <th>必要席数</th>
                            </tr>
                        </thead>
                        <tbody id="builder-shortage-body">
                            <tr><td colspan="4" class="muted">現在、割当不足はありません。</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

<section class="controls">
        <div>
            <label for="startDate">開始日</label>
            <input type="date" id="startDate">
        </div>
        <div>
            <label for="viewMode">表示範囲</label>
            <select id="viewMode">
                <option value="week">週次 (7日)</option>
                <option value="month">月次</option>
                <option value="custom">日付指定</option>
            </select>
        </div>
        <div>
            <label for="endDate">終了日</label>
            <input type="date" id="endDate">
        </div>
        <div style="align-self: flex-end;">
            <button class="btn btn-secondary" id="loadBtn">シフトを表示</button>
        </div>
        <div class="status-bar" id="metaInfo"></div>
    </section>

    <div class="layout">
        <section class="grid-panel">
            <div class="grid-wrapper">
                <table id="gridTable">
                    <thead></thead>
                    <tbody></tbody>
                </table>
            </div>
        </section>
        <section class="editor-panel">
            <h2>選択セルのシフト編集</h2>
            <div class="form-group">
                <label for="employeeSelect">従業員</label>
                <select id="employeeSelect"></select>
            </div>
            <div class="form-group">
                <label for="workDateInput">日付</label>
                <input type="date" id="workDateInput">
            </div>
            <div class="form-group">
                <label for="shiftNameInput">シフト名（任意）</label>
                <input type="text" id="shiftNameInput" placeholder="例: 早番 / 遅番 / 窓口A / 事務サポート">
                <div class="field-hint">画面上の表示ラベルです。未入力でもかまいません。</div>
            </div>
            <div class="form-group">
                <label for="skillSelect">スキル</label>
                <select id="skillSelect">
                    <option value="">指定なし（汎用枠）</option>
                </select>
                <div class="field-hint" id="skillHint">従業員を選ぶと、保有スキルが表示されます。</div>
            </div>
            <div class="form-group chip-row chip-row--split">
                <div>
                    <label for="startTimeInput">開始</label>
                    <input type="time" id="startTimeInput" step="900">
                </div>
                <div>
                    <label for="endTimeInput">終了</label>
                    <input type="time" id="endTimeInput" step="900">
                </div>
            </div>
            <div class="form-group">
                <label>休憩</label>
                <div id="breakList" class="break-list"></div>
                <div class="chip-row">
                    <button class="btn btn-secondary" id="breakAddBtn" type="button">休憩を追加</button>
                    <button class="btn btn-secondary ghost" id="breakSuggestBtn" type="button">推奨を反映</button>
                </div>
                <div class="status-bar" id="breakHint">例: 15 / 10 など、分単位で自由に設定できます</div>
            </div>
            <div class="form-group">
                <label for="shiftTypeSelect">シフト種別</label>
                <select id="shiftTypeSelect">
                    <option value="normal">需要枠（通常）</option>
                    <option value="free">空き（待機）</option>
                    <option value="off">休日</option>
                    <option value="leave">有給</option>
                </select>
            </div>
            <div class="form-group chip-row">
                <button class="btn btn-secondary" id="newBtn">新規追加</button>
                <button class="btn btn-primary" id="updateBtn">選択を更新</button>
                <button class="btn btn-danger" id="deleteBtn">削除</button>
            </div>
            <div class="status-bar" id="selectionInfo">未選択</div>
            <div class="status-bar" id="pendingInfo">未保存の変更: 0 件</div>
            <div class="form-group chip-row persist-actions">
                <button class="btn btn-secondary" id="discardBtn">調整を破棄</button>
                <button class="btn btn-primary" id="saveBtn">調整を保存</button>
            </div>
            <div class="message" id="messageBox"></div>
        </section>
    </div>
</div>

<script src="/js/app.js"></script>
<script>
(() => {
    const statusHints = {
        idle: '生成の準備が整いました',
        processing: 'シフトを計算しています',
        success: '最新のシフトデータが反映されました',
        error: 'エラー内容を確認してください'
    };
    let dom = {};

    function ready() {
        dom = {
            year: document.getElementById('builder-year'),
            month: document.getElementById('builder-month'),
            granularity: document.getElementById('builder-granularity'),
            prev: document.getElementById('builder-prev-month'),
            next: document.getElementById('builder-next-month'),
            refresh: document.getElementById('builder-refresh'),
            refreshSecondary: document.getElementById('builder-refresh-secondary'),
            downloadCsv: document.getElementById('builder-download-csv'),
            generate: document.getElementById('builder-generate'),
            reset: document.getElementById('builder-reset'),
            message: document.getElementById('builder-message'),
            statusPill: document.getElementById('builder-status-pill'),
            statusText: document.getElementById('builder-status-text'),
            period: document.getElementById('builder-period'),
            assignmentCount: document.getElementById('builder-assignment-count'),
            employeeCount: document.getElementById('builder-employee-count'),
            shortageCount: document.getElementById('builder-shortage-count'),
            shortageNote: document.getElementById('builder-shortage-note'),
            infoAssignments: document.getElementById('builder-info-assignments'),
            infoEmployees: document.getElementById('builder-info-employees'),
            infoDays: document.getElementById('builder-info-days'),
            shortagePanel: document.getElementById('builder-shortage-panel'),
            shortageBody: document.getElementById('builder-shortage-body'),
            hideShortage: document.getElementById('builder-hide-shortage'),
            scrollGrid: document.getElementById('builder-scroll-grid')
        };
        if (!dom.year || !dom.month) {
            return;
        }
        setupMonthOptions();
        const now = new Date();
        setBuilderPeriod(now.getFullYear(), now.getMonth() + 1);
        bindEvents();
        setBuilderStatus('idle', '待機中');
        loadBuilderSummary();
    }

    function bindEvents() {
        dom.prev?.addEventListener('click', () => changeBuilderMonth(-1));
        dom.next?.addEventListener('click', () => changeBuilderMonth(1));
        dom.year?.addEventListener('change', () => {
            loadBuilderSummary(true);
            syncGridRangeToBuilder();
        });
        dom.month?.addEventListener('change', () => {
            loadBuilderSummary(true);
            syncGridRangeToBuilder();
        });
        dom.refresh?.addEventListener('click', () => loadBuilderSummary(true));
        dom.refreshSecondary?.addEventListener('click', () => loadBuilderSummary(true));
        dom.downloadCsv?.addEventListener('click', handleBuilderCsvDownload);
        dom.generate?.addEventListener('click', handleBuilderGenerate);
        dom.reset?.addEventListener('click', handleBuilderReset);
        dom.hideShortage?.addEventListener('click', () => {
            if (dom.shortagePanel) dom.shortagePanel.style.display = 'none';
        });
        dom.scrollGrid?.addEventListener('click', () => {
            document.getElementById('gridTable')?.scrollIntoView({ behavior: 'smooth' });
        });
    }

    function setupMonthOptions() {
        if (!dom.month) return;
        dom.month.innerHTML = '';
        for (let month = 1; month <= 12; month++) {
            const option = document.createElement('option');
            option.value = month;
            option.textContent = `${month}月`;
            dom.month.appendChild(option);
        }
    }

    function changeBuilderMonth(offset) {
        const { year, month } = getBuilderPeriod();
        const date = new Date(year, month - 1 + offset, 1);
        setBuilderPeriod(date.getFullYear(), date.getMonth() + 1);
        loadBuilderSummary();
        syncGridRangeToBuilder();
    }

    function setBuilderPeriod(year, month) {
        if (dom.year) dom.year.value = year;
        if (dom.month) dom.month.value = month;
        if (dom.period) dom.period.textContent = `${year}年${month}月`;
    }

    function getBuilderPeriod() {
        const now = new Date();
        return {
            year: dom.year ? (parseInt(dom.year.value, 10) || now.getFullYear()) : now.getFullYear(),
            month: dom.month ? (parseInt(dom.month.value, 10) || (now.getMonth() + 1)) : (now.getMonth() + 1)
        };
    }

    function formatYmd(year, month, day) {
        const pad = (value) => String(value).padStart(2, '0');
        return `${year}-${pad(month)}-${pad(day)}`;
    }

    function syncGridRangeToBuilder(autoReload = true) {
        const startInput = document.getElementById('startDate');
        const endInput = document.getElementById('endDate');
        if (!startInput || !endInput) return;
        const viewMode = document.getElementById('viewMode');
        const { year, month } = getBuilderPeriod();
        const lastDay = new Date(year, month, 0).getDate();
        const startValue = formatYmd(year, month, 1);
        const endValue = formatYmd(year, month, lastDay);

        if (viewMode) viewMode.value = 'month';

        const startChanged = startInput.value !== startValue;
        startInput.value = startValue;
        if (startChanged) {
            startInput.dispatchEvent(new Event('change', { bubbles: true }));
        }

        const endChanged = endInput.value !== endValue;
        endInput.value = endValue;
        if (endChanged) {
            endInput.dispatchEvent(new Event('change', { bubbles: true }));
        }

        if (autoReload) {
            window.reloadScheduleGrid?.();
        }
    }

    async function handleBuilderGenerate() {
        const { year, month } = getBuilderPeriod();
        setBuilderMessage('生成を開始しました...', 'info');
        setBuilderStatus('processing', '生成中...');
        renderBuilderShortages([]);
        dom.generate.disabled = true;
        try {
            const gran = dom.granularity ? Number(dom.granularity.value || '60') : 60;
            const response = await callApi(`/api/schedule/generate/demand/async?year=${year}&month=${month}&granularity=${gran}&mode=simple`, { method: 'POST' });
            setBuilderMessage(response.message || 'シフトを生成しました。', 'success');
            const shortages = (response.meta && response.meta.shortages) || [];
            renderBuilderShortages(shortages);
            await pollJobStatus(year, month);
            await loadBuilderSummary();
            window.reloadScheduleGrid?.();
            setBuilderStatus('success', '生成済み');
        } catch (error) {
            setBuilderStatus('error', '生成に失敗');
            setBuilderMessage(error.message || 'シフト生成に失敗しました。', 'error');
        } finally {
            dom.generate.disabled = false;
        }
    }

    async function handleBuilderReset() {
        const { year, month } = getBuilderPeriod();
        if (!confirm(`${year}年${month}月のシフトを初期化します。よろしいですか？`)) {
            return;
        }
        dom.reset.disabled = true;
        setBuilderStatus('processing', '初期化中...');
        setBuilderMessage('', 'info');
        try {
            await callApi(`/api/schedule/reset?year=${year}&month=${month}`, { method: 'DELETE' });
            setBuilderMessage('シフトを初期化しました。', 'success');
            renderBuilderShortages([]);
            await loadBuilderSummary();
            window.reloadScheduleGrid?.();
            setBuilderStatus('idle', '初期化済み');
        } catch (error) {
            setBuilderStatus('error', '初期化に失敗');
            setBuilderMessage(error.message || 'シフト初期化に失敗しました。', 'error');
        } finally {
            dom.reset.disabled = false;
        }
    }

    async function handleBuilderCsvDownload(event) {
        const { year, month } = getBuilderPeriod();
        const btn = dom.downloadCsv || event?.currentTarget || null;
        if (btn) btn.disabled = true;
        try {
            const res = await fetch(`/api/schedule/export/csv?year=${year}&month=${month}`, { credentials: 'include' });
            if (!res.ok) throw new Error('CSVダウンロードに失敗しました');
            const blob = await res.blob();
            const link = document.createElement('a');
            const url = window.URL.createObjectURL(blob);
            link.href = url;
            link.download = `schedule-${year}-${String(month).padStart(2, '0')}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(url);
        } catch (error) {
            alert(error.message || 'CSVダウンロードに失敗しました');
        } finally {
            if (btn) btn.disabled = false;
        }
    }

    async function loadBuilderSummary(showMessage = false) {
        const { year, month } = getBuilderPeriod();
        if (dom.year && dom.month) {
            if (!dom.year.value) dom.year.value = year;
            if (!dom.month.value) dom.month.value = month;
        }
        setBuilderStatus('processing', '読み込み中...');
        try {
            const response = await callApi(`/api/schedule?year=${year}&month=${month}`);
            const assignments = response.data || [];
            updateBuilderHero(response.meta || {}, assignments);
            if (showMessage && response.message) {
                setBuilderMessage(response.message, 'info');
            } else {
                setBuilderMessage('', 'info');
            }
            setBuilderStatus('success', assignments.length ? '最新データ' : 'シフトなし');
        } catch (error) {
            updateBuilderHero({}, []);
            setBuilderStatus('error', '取得に失敗');
            setBuilderMessage(error.message || 'シフトの取得に失敗しました。', 'error');
        }
    }

    async function pollJobStatus(year, month) {
        if (!dom.message) return;
        let delay = 700;
        const maxWait = Date.now() + 5 * 60 * 1000;
        while (Date.now() < maxWait) {
            await new Promise(r => setTimeout(r, delay));
            try {
                const status = await callApi(`/api/schedule/jobs/status?year=${year}&month=${month}`, {}, { expectSuccess: false });
                const meta = (status && (status.data || status.meta)) || {};
                if (meta.done) {
                    setBuilderMessage('生成完了。反映中...', 'info');
                    return;
                }
                const count = Number(meta.count || 0);
                setBuilderMessage(`生成中... ${count}件`, 'info');
            } catch (_) { }
            delay = Math.min(2000, Math.floor(delay * 1.4));
        }
    }

    function updateBuilderHero(meta, assignments) {
        const { year, month } = getBuilderPeriod();
        const periodText = `${meta.year ?? year}年${meta.month ?? month}月`;
        if (dom.period) dom.period.textContent = periodText;
        const count = meta.count ?? assignments.length;
        if (dom.assignmentCount) dom.assignmentCount.textContent = count;
        if (dom.infoAssignments) dom.infoAssignments.textContent = count;
        const unique = meta.uniqueEmployees ?? new Set(assignments.map(item => item.employeeName)).size;
        if (dom.employeeCount) dom.employeeCount.textContent = unique;
        if (dom.infoEmployees) dom.infoEmployees.textContent = unique;
        const days = meta.workingDays ?? new Set(assignments.map(item => item.workDate)).size;
        if (dom.infoDays) dom.infoDays.textContent = days;
    }

    function renderBuilderShortages(rows) {
        const list = Array.isArray(rows) ? rows : [];
        const count = list.length;
        if (dom.shortageCount) dom.shortageCount.textContent = count;
        if (dom.shortageNote) {
            dom.shortageNote.textContent = count
                ? `${count}件の不足があります。`
                : '不足データはありません。';
        }
        if (!dom.shortagePanel || !dom.shortageBody) return;
        if (!count) {
            dom.shortagePanel.style.display = 'none';
            dom.shortageBody.innerHTML = '<tr><td colspan="4" class="muted">不足データはありません</td></tr>';
            return;
        }
        dom.shortagePanel.style.display = 'block';
        dom.shortageBody.innerHTML = list.map(row => {
            const assigned = row.assigned ?? '-';
            const required = row.required ?? '-';
            return `<tr><td>${row.workDate || '-'}</td><td>${row.shiftName || '-'}</td><td>${assigned}</td><td>${required}</td></tr>`;
        }).join('');
    }

    function setBuilderMessage(text, type = 'info') {
        if (!dom.message) return;
        if (!text) {
            dom.message.textContent = '';
            dom.message.className = 'builder-message';
            dom.message.style.display = 'none';
            return;
        }
        dom.message.textContent = text;
        dom.message.style.display = 'block';
        dom.message.className = `builder-message ${type}`;
    }

    function setBuilderStatus(state, text) {
        const target = state || 'idle';
        if (dom.statusPill) {
            dom.statusPill.classList.remove('idle', 'processing', 'success', 'error');
            dom.statusPill.classList.add(target);
            dom.statusPill.textContent = text || '待機中';
        }
        if (dom.statusText) {
            dom.statusText.textContent = statusHints[target] || text || 'ステータスを確認してください';
        }
    }

    async function callApi(url, options = {}, config = {}) {
        const expectSuccess = config.expectSuccess !== false;
        const requestOptions = {
            credentials: 'include',
            ...options
        };
        requestOptions.headers = {
            'Content-Type': 'application/json',
            ...(options.headers || {})
        };
        if (requestOptions.body && typeof requestOptions.body !== 'string') {
            requestOptions.body = JSON.stringify(requestOptions.body);
        }
        const response = await fetch(url, requestOptions);
        const contentType = response.headers.get('content-type') || '';
        let data = null;
        if (contentType.includes('application/json')) {
            data = await response.json();
        } else {
            const text = await response.text();
            if (text) {
                try { data = JSON.parse(text); } catch { data = { message: text }; }
            }
        }
        if (!response.ok) {
            throw new Error(data?.message || `HTTP ${response.status}`);
        }
        if (expectSuccess && data && data.success === false) {
            throw new Error(data.message || 'リクエストに失敗しました');
        }
        return data;
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', ready);
    } else {
        ready();
    }
})();
</script>
<script>
(async () => {
    const state = {
        employees: [],
        days: [],
        assignments: new Map(),
        skillLookup: new Map(),
        demandCache: new Map(),
        demandRequests: new Map(),
        pending: { create: [], update: [], delete: [] },
        clipboard: null,
        selectedAssignmentId: null,
        activeCellKey: null,
        tempCounter: 0,
        formBreaks: [],
        breakSettings: {
            shortBreakEnabled: false,
            shortBreakMinutes: 15,
            minShiftMinutes: 180,
            applyToShortShifts: true
        },
        currentEmployeeHasSkills: false,
        lastPlaceholderType: null,
        timeTouched: { start: false, end: false },
        lastAutoShiftName: ''
    };

    const dom = {
        startDate: document.getElementById('startDate'),
        endDate: document.getElementById('endDate'),
        viewMode: document.getElementById('viewMode'),
        loadBtn: document.getElementById('loadBtn'),
        saveBtn: document.getElementById('saveBtn'),
        discardBtn: document.getElementById('discardBtn'),
        gridTable: document.getElementById('gridTable'),
        employeeSelect: document.getElementById('employeeSelect'),
        workDateInput: document.getElementById('workDateInput'),
        shiftNameInput: document.getElementById('shiftNameInput'),
        skillSelect: document.getElementById('skillSelect'),
        skillHint: document.getElementById('skillHint'),
        startTimeInput: document.getElementById('startTimeInput'),
        endTimeInput: document.getElementById('endTimeInput'),
        breakList: document.getElementById('breakList'),
        breakHint: document.getElementById('breakHint'),
        breakAddBtn: document.getElementById('breakAddBtn'),
        breakSuggestBtn: document.getElementById('breakSuggestBtn'),
        shiftTypeSelect: document.getElementById('shiftTypeSelect'),
        newBtn: document.getElementById('newBtn'),
        updateBtn: document.getElementById('updateBtn'),
        deleteBtn: document.getElementById('deleteBtn'),
        selectionInfo: document.getElementById('selectionInfo'),
        pendingInfo: document.getElementById('pendingInfo'),
        messageBox: document.getElementById('messageBox'),
        metaInfo: document.getElementById('metaInfo')
    };

    renderBreakList();

    const weekdays = ['日', '月', '火', '水', '木', '金', '土'];
    const PLACEHOLDER_LIMITS = {
        free: { start: '00:00', end: '00:05' },
        off: { start: '00:00', end: '00:05' },
        leave: { start: '09:00', end: '18:00' },
        default: { start: '09:00', end: '18:00' }
    };
    const BREAK_ROUND_STEP = 15;

    function timeToMinutes(str) {
        if (!str || str.length < 4) return null;
        const [h, m] = str.split(':').map(Number);
        if (Number.isNaN(h) || Number.isNaN(m)) return null;
        return (h * 60) + m;
    }

    function minutesToTime(mins) {
        const clamped = Math.max(0, mins);
        const h = String(Math.floor(clamped / 60)).padStart(2, '0');
        const m = String(clamped % 60).padStart(2, '0');
        return `${h}:${m}`;
    }

    function roundMinutesToStep(value, step = BREAK_ROUND_STEP) {
        if (!Number.isFinite(value)) return value;
        if (!step || step <= 0) return value;
        return Math.round(value / step) * step;
    }

    function alignBreakStart(candidate, shiftStart, shiftEnd, duration, step = BREAK_ROUND_STEP) {
        if (!Number.isFinite(candidate)) return shiftStart;
        const rounded = roundMinutesToStep(candidate, step);
        const minStart = Number.isFinite(shiftStart) ? shiftStart : 0;
        const maxStartBase = Number.isFinite(shiftEnd) ? shiftEnd : minStart;
        const maxStart = Math.max(minStart, maxStartBase - Math.max(0, duration || 0));
        return Math.min(Math.max(rounded, minStart), maxStart);
    }

    function normalizeTimeValue(value) {
        if (value == null) return '';
        if (typeof value === 'string') {
            return value.slice(0, 5);
        }
        return value;
    }

    function recommendedLunchMinutes(startStr, endStr) {
        const start = timeToMinutes(startStr);
        const end = timeToMinutes(endStr);
        if (start == null || end == null || end <= start) return 0;
        const duration = end - start;
        if (duration >= 480) return 60;
        if (duration >= 360) return 45;
        return 0;
    }

    function suggestBreakSet() {
        const startStr = dom.startTimeInput.value;
        const endStr = dom.endTimeInput.value;
        const start = timeToMinutes(startStr);
        const end = timeToMinutes(endStr);
        if (start == null || end == null || end <= start) return [];
        const duration = end - start;
        const result = [];
        const lunchMinutes = recommendedLunchMinutes(startStr, endStr);
        if (lunchMinutes > 0) {
            const slack = Math.max(0, duration - lunchMinutes);
            const offset = Math.floor(slack / 2);
            const lunchCandidate = start + offset;
            const lunchStartMinutes = alignBreakStart(lunchCandidate, start, end, lunchMinutes);
            const lunchEndMinutes = lunchStartMinutes + lunchMinutes;
            const lunchStart = minutesToTime(lunchStartMinutes);
            const lunchEnd = minutesToTime(lunchEndMinutes);
            result.push({
                type: 'LUNCH',
                start: lunchStart,
                end: lunchEnd,
                autoGenerated: true
            });
        }
        if (state.breakSettings.shortBreakEnabled) {
            const shortMinutes = Math.max(5, state.breakSettings.shortBreakMinutes || 15);
            const minShift = Math.max(60, state.breakSettings.minShiftMinutes || 180);
            if (duration >= minShift) {
                let shortStartMinutes;
                if (result.length > 0) {
                    const lunchEnd = result[0].end;
                    const lunchEndMinutes = timeToMinutes(lunchEnd);
                    const remaining = timeToMinutes(endStr) - lunchEndMinutes;
                    const offset = Math.max(0, Math.floor((remaining - shortMinutes) / 2));
                    shortStartMinutes = alignBreakStart(lunchEndMinutes + offset, timeToMinutes(lunchEnd), end, shortMinutes);
                } else if (state.breakSettings.applyToShortShifts) {
                    const offset = Math.max(0, Math.floor((duration - shortMinutes) / 2));
                    shortStartMinutes = alignBreakStart(start + offset, start, end, shortMinutes);
                }
                if (Number.isFinite(shortStartMinutes)) {
                    const shortStart = minutesToTime(shortStartMinutes);
                    const shortEnd = minutesToTime(shortStartMinutes + shortMinutes);
                    result.push({
                        type: 'SHORT',
                        start: shortStart,
                        end: shortEnd,
                        autoGenerated: true
                    });
                }
            }
        }
        return result;
    }
    function effectiveTimeValue(input) {
        if (!input) return null;
        const value = input.disabled ? (input.dataset.savedValue || '') : input.value;
        return value || null;
    }

    function renderBreakList() {
        if (!dom.breakList) return;
        const items = state.formBreaks;
        if (!items.length) {
            dom.breakList.innerHTML = '<p class="muted">休憩は未設定です。</p>';
            return;
        }
        dom.breakList.innerHTML = items.map((br, idx) => {
            return `<div class="break-row" data-break-index="${idx}">
                <select data-break-field="type">
                    <option value="LUNCH"${br.type === 'LUNCH' ? ' selected' : ''}>昼休憩</option>
                    <option value="SHORT"${br.type === 'SHORT' ? ' selected' : ''}>小休憩</option>
                </select>
                <input type="time" data-break-field="start" value="${br.start || ''}">
                <span>〜</span>
                <input type="time" data-break-field="end" value="${br.end || ''}">
                <button type="button" class="btn btn-secondary" data-break-remove="${idx}">削除</button>
            </div>`;
        }).join('');
        dom.breakList.querySelectorAll('[data-break-field]').forEach(input => {
            input.addEventListener('input', handleBreakFieldChange);
        });
        dom.breakList.querySelectorAll('[data-break-remove]').forEach(btn => {
            btn.addEventListener('click', () => removeBreakRow(Number(btn.dataset.breakRemove)));
        });
        updateBreakHint();
    }

    function handleBreakFieldChange(event) {
        const wrapper = event.currentTarget.closest('[data-break-index]');
        if (!wrapper) return;
        const index = Number(wrapper.dataset.breakIndex);
        const field = event.currentTarget.dataset.breakField;
        const value = event.currentTarget.value;
        if (!Number.isFinite(index) || index < 0 || index >= state.formBreaks.length) return;
        const target = state.formBreaks[index];
        target[field] = value;
    }

    function addBreakRow(type = 'SHORT') {
        state.formBreaks.push({
            id: null,
            type,
            start: '',
            end: '',
            autoGenerated: false
        });
        renderBreakList();
        updateBreakHint();
    }

    function removeBreakRow(index) {
        state.formBreaks.splice(index, 1);
        renderBreakList();
        updateBreakHint();
    }

    function updateBreakHint() {
        if (!dom.breakHint) return;
        if (!state.formBreaks.length) {
            dom.breakHint.textContent = '例: 12:00〜12:45 や 15:00〜15:10 など、時間帯で自由に設定できます';
            return;
        }
        const total = state.formBreaks.map(br => {
            const start = timeToMinutes(br.start);
            const end = timeToMinutes(br.end);
            if (start == null || end == null || end <= start) return 0;
            return end - start;
        }).reduce((sum, v) => sum + v, 0);
        dom.breakHint.textContent = `設定中: ${state.formBreaks.length}件 / 合計 ${total}分`;
    }

    function hydrateBreaks(assign) {
        if (assign && Array.isArray(assign.breaks) && assign.breaks.length) {
            return assign.breaks.map(br => ({
                id: br.id || null,
                type: br.type || 'LUNCH',
                start: br.start || '',
                end: br.end || '',
                autoGenerated: !!br.autoGenerated
            }));
        }
        if (assign && assign.breakStart && assign.breakEnd) {
            return [{
                id: null,
                type: 'LUNCH',
                start: assign.breakStart,
                end: assign.breakEnd,
                autoGenerated: false
            }];
        }
        return [];
    }

    function resetTimeTouched() {
        state.timeTouched.start = false;
        state.timeTouched.end = false;
    }

    function registerSkillMeta(meta) {
        if (!meta || meta.id == null) return;
        const key = String(meta.id);
        state.skillLookup.set(key, {
            id: meta.id,
            code: meta.code || '',
            name: meta.name || ''
        });
    }

    function getSkillMeta(skillId) {
        if (skillId == null) return null;
        const key = String(skillId);
        if (state.skillLookup.has(key)) {
            return state.skillLookup.get(key);
        }
        for (const emp of state.employees) {
            const list = Array.isArray(emp.skills) ? emp.skills : [];
            const found = list.find(sk => Number(sk.id) === Number(skillId));
            if (found) {
                return {
                    id: found.id,
                    code: found.code || '',
                    name: found.name || ''
                };
            }
        }
        return null;
    }

    function rebuildSkillLookup() {
        state.skillLookup = new Map();
        state.employees.forEach(emp => {
            (emp.skills || []).forEach(registerSkillMeta);
        });
        state.assignments.forEach(assign => {
            if (assign.skillId != null) {
                registerSkillMeta({
                    id: assign.skillId,
                    code: assign.skillCode,
                    name: assign.skillName
                });
            }
        });
    }

    function refreshSkillOptions(selectedSkillId = null) {
        if (!dom.skillSelect) return { hasSkills: false };
        const employeeId = Number(dom.employeeSelect.value);
        const employee = state.employees.find(e => Number(e.id) === employeeId);
        const available = Array.isArray(employee?.skills) ? [...employee.skills] : [];
        if (selectedSkillId != null && !available.some(sk => Number(sk.id) === Number(selectedSkillId))) {
            const extra = getSkillMeta(selectedSkillId);
            if (extra) {
                available.push(extra);
            }
        }
        available.sort((a, b) => {
            const labelA = (a?.name && a.name.trim()) || a?.code || '';
            const labelB = (b?.name && b.name.trim()) || b?.code || '';
            return labelA.localeCompare(labelB, 'ja');
        });
        dom.skillSelect.innerHTML = '';
        const defaultOpt = document.createElement('option');
        defaultOpt.value = '';
        defaultOpt.textContent = '指定なし（汎用枠）';
        dom.skillSelect.appendChild(defaultOpt);
        available.forEach(skill => {
            if (!skill || skill.id == null) return;
            const option = document.createElement('option');
            option.value = skill.id;
            const label = (skill.name && skill.name.trim())
                ? skill.name.trim()
                : (skill.code ? `コード: ${skill.code}` : `ID: ${skill.id}`);
            option.textContent = label;
            dom.skillSelect.appendChild(option);
        });
        if (selectedSkillId != null) {
            dom.skillSelect.value = String(selectedSkillId);
        } else {
            dom.skillSelect.value = '';
        }
        return { hasSkills: available.length > 0 };
    }

    function handleEmployeeChange(selectedSkillId = null, options = {}) {
        if (!dom.skillSelect) return;
        const preserveShiftName = !!options.preserveShiftName;
        const info = refreshSkillOptions(selectedSkillId);
        state.currentEmployeeHasSkills = info.hasSkills;
        syncSkillAvailability();
        if (!preserveShiftName) {
            maybeUpdateShiftName('employee-change');
        }
    }

    function syncSkillAvailability() {
        if (!dom.skillSelect) return;
        const placeholder = currentPlaceholderType();
        if (placeholder) {
            dom.skillSelect.disabled = true;
            dom.skillSelect.value = '';
            if (dom.skillHint) {
                dom.skillHint.textContent = '空き・休日・有給ではスキル指定は不要です。';
            }
            return;
        }
        if (!state.currentEmployeeHasSkills) {
            dom.skillSelect.disabled = true;
            dom.skillSelect.value = '';
            if (dom.skillHint) {
                dom.skillHint.textContent = 'この従業員には登録済みスキルがありません。';
            }
            return;
        }
        dom.skillSelect.disabled = false;
        if (dom.skillHint) {
            dom.skillHint.textContent = '需要枠に反映するスキルを選択してください。';
        }
    }

    function getSelectedSkillId() {
        if (!dom.skillSelect || dom.skillSelect.disabled) return null;
        const value = dom.skillSelect.value;
        return value ? Number(value) : null;
    }

    function enrichAssignmentWithSkill(target, skillId) {
        target.skillId = skillId ?? null;
        if (skillId == null) {
            target.skillName = null;
            target.skillCode = null;
            return;
        }
        const meta = getSkillMeta(skillId);
        if (meta) {
            registerSkillMeta(meta);
            target.skillName = meta.name || '';
            target.skillCode = meta.code || '';
        } else {
            target.skillName = target.skillName || '';
            target.skillCode = target.skillCode || '';
        }
    }

    async function fetchDemandForDate(date) {
        if (!date) return [];
        if (state.demandCache.has(date)) {
            return state.demandCache.get(date);
        }
        if (state.demandRequests.has(date)) {
            return state.demandRequests.get(date);
        }
        const pending = (async () => {
            try {
                const res = await fetch(`/api/demand/effective?date=${date}`);
                if (!res.ok) throw new Error('demand fetch failed');
                const json = await res.json();
                const normalized = normalizeDemandIntervals(json?.data);
                state.demandCache.set(date, normalized);
                return normalized;
            } catch (err) {
                console.warn('Failed to load demand intervals', err);
                const fallback = [];
                state.demandCache.set(date, fallback);
                return fallback;
            } finally {
                state.demandRequests.delete(date);
            }
        })();
        state.demandRequests.set(date, pending);
        return pending;
    }

    function normalizeDemandIntervals(raw) {
        if (!Array.isArray(raw)) return [];
        return raw
            .filter(item => item && item.startTime && item.endTime)
            .map(item => ({
                id: item.id,
                start: formatHm(item.startTime),
                end: formatHm(item.endTime),
                skillId: item.skill && item.skill.id != null ? String(item.skill.id) : null
            }));
    }

    function formatHm(value) {
        if (!value) return '';
        if (typeof value === 'string') {
            return value.slice(0, 5);
        }
        return value.toString().slice(0, 5);
    }

    function pickDemandCandidate(intervals, skillId) {
        if (!Array.isArray(intervals) || !intervals.length) return null;
        const sorted = [...intervals].sort((a, b) => {
            return (timeToMinutes(a.start) ?? 0) - (timeToMinutes(b.start) ?? 0);
        });
        const target = skillId != null ? String(skillId) : null;
        if (target) {
            const match = sorted.find(item => item.skillId && item.skillId === target);
            if (match) return match;
        }
        return sorted[0] || null;
    }

    function buildShiftNameSuggestion() {
        const skillId = getSelectedSkillId();
        const skillMeta = getSkillMeta(skillId);
        const base = (skillMeta?.name && skillMeta.name.trim())
            || (skillMeta?.code && skillMeta.code.trim())
            || '需要枠';
        const start = normalizeTimeValue(dom.startTimeInput.value);
        const end = normalizeTimeValue(dom.endTimeInput.value);
        if (start && end) {
            return `${base} ${start}-${end}`;
        }
        return base;
    }

    function normalizeShiftName(value) {
        if (!value) return '';
        return value.replace(/\s+/g, ' ').trim();
    }

    function setShiftNameSuggestion(text) {
        if (!dom.shiftNameInput) return;
        dom.shiftNameInput.value = text;
        state.lastAutoShiftName = text;
    }

    function maybeUpdateShiftName(reason = 'default') {
        if (!dom.shiftNameInput || currentPlaceholderType()) return;
        const currentNormalized = normalizeShiftName(dom.shiftNameInput.value);
        const needsAuto =
            !currentNormalized ||
            currentNormalized === '空き（待機）' ||
            currentNormalized.toUpperCase() === 'FREE';
        const wasAuto = state.lastAutoShiftName && currentNormalized === state.lastAutoShiftName;
        if (!needsAuto && !wasAuto) {
            return;
        }
        const suggestion = buildShiftNameSuggestion();
        if (!suggestion) return;
        if (!needsAuto && wasAuto && reason === 'skill-change') {
            setShiftNameSuggestion(suggestion);
            return;
        }
        if (!needsAuto && wasAuto && reason === 'time-change') {
            setShiftNameSuggestion(suggestion);
            return;
        }
        if (needsAuto || (wasAuto && reason === 'employee-change')) {
            setShiftNameSuggestion(suggestion);
        }
    }

    function shouldAutofillTime(input, reason) {
        if (!input) return false;
        if (reason === 'skill-change' || reason === 'placeholder-exit') {
            return true;
        }
        if (!input.value) return true;
        const key = input === dom.startTimeInput ? 'start' : 'end';
        if (state.timeTouched[key]) {
            return false;
        }
        if (reason === 'date-change' || reason === 'employee-change') {
            return true;
        }
        if (input.value === '00:00' || input.value === '00:05') {
            return true;
        }
        return false;
    }

    async function autosetTimesForDemand(reason = 'skill-change') {
        if (currentPlaceholderType()) return;
        const date = dom.workDateInput.value;
        if (!date) return;
        let intervals = [];
        try {
            intervals = await fetchDemandForDate(date);
        } catch (_) {
            intervals = [];
        }
        const skillId = getSelectedSkillId();
        const candidate = pickDemandCandidate(intervals, skillId);
        const fallbackStart = '08:00';
        const fallbackEnd = '17:00';
        const startValue = candidate?.start || fallbackStart;
        const endValue = candidate?.end || fallbackEnd;
        if (shouldAutofillTime(dom.startTimeInput, reason)) {
            dom.startTimeInput.value = startValue;
        }
        if (shouldAutofillTime(dom.endTimeInput, reason)) {
            dom.endTimeInput.value = endValue;
        }
        updateBreakHint();
        maybeUpdateShiftName('time-change');
    }

    async function fetchBreakSettings() {
        try {
            const res = await fetch('/api/config/break-settings');
            if (!res.ok) return;
            const data = await res.json();
            state.breakSettings.shortBreakEnabled = !!data.shortBreakEnabled;
            state.breakSettings.shortBreakMinutes = data.shortBreakMinutes ?? 15;
            state.breakSettings.minShiftMinutes = data.minShiftMinutes ?? 180;
            state.breakSettings.applyToShortShifts = data.applyToShortShifts ?? true;
        } catch (err) {
            console.warn('Failed to load break settings', err);
        }
    }
    function currentPlaceholderType() {
        if (!dom.shiftTypeSelect) return null;
        const value = dom.shiftTypeSelect.value;
        if (value === 'free' || value === 'off' || value === 'leave') return value;
        return null;
    }

    function maskShiftInputs(type) {
        if (!dom.startTimeInput.dataset.savedValue && dom.startTimeInput.value) {
            dom.startTimeInput.dataset.savedValue = dom.startTimeInput.value;
        }
        if (!dom.endTimeInput.dataset.savedValue && dom.endTimeInput.value) {
            dom.endTimeInput.dataset.savedValue = dom.endTimeInput.value;
        }
        dom.startTimeInput.value = '';
        dom.endTimeInput.value = '';
        dom.startTimeInput.disabled = true;
        dom.endTimeInput.disabled = true;

        state.formBreaks = [];
        renderBreakList();
        dom.breakSuggestBtn.disabled = true;
    }

    function unmaskShiftInputs() {
        if (dom.startTimeInput.dataset.savedValue !== undefined) {
            if (!dom.startTimeInput.value) {
                dom.startTimeInput.value = dom.startTimeInput.dataset.savedValue;
            }
            delete dom.startTimeInput.dataset.savedValue;
        }
        if (dom.endTimeInput.dataset.savedValue !== undefined) {
            if (!dom.endTimeInput.value) {
                dom.endTimeInput.value = dom.endTimeInput.dataset.savedValue;
            }
            delete dom.endTimeInput.dataset.savedValue;
        }
        dom.startTimeInput.disabled = false;
        dom.endTimeInput.disabled = false;

        dom.breakSuggestBtn.disabled = false;
    }

    function syncPlaceholderUI() {
        const prevType = state.lastPlaceholderType;
        const type = currentPlaceholderType();
        state.lastPlaceholderType = type;
        if (type === 'leave') {
            dom.shiftNameInput.value = '有休';
        } else if (type === 'free') {
            dom.shiftNameInput.value = '空き（待機）';
        }
        if (type) {
            maskShiftInputs(type);
            syncSkillAvailability();
        } else {
            unmaskShiftInputs();
            syncSkillAvailability();
            if (prevType) {
                resetTimeTouched();
                autosetTimesForDemand('placeholder-exit');
                maybeUpdateShiftName('placeholder-exit');
            }
        }
    }

    function initDates() {
        const today = new Date();
        const monday = new Date(today);
        const day = monday.getDay();
        const diff = (day === 0 ? -6 : 1 - day);
        monday.setDate(monday.getDate() + diff);
        const weekEnd = new Date(monday);
        weekEnd.setDate(weekEnd.getDate() + 6);
        dom.startDate.value = formatInputDate(monday);
        dom.endDate.value = formatInputDate(weekEnd);
    }

    function formatInputDate(date) {
        return date.toISOString().slice(0, 10);
    }

    function adjustEndByMode() {
        const mode = dom.viewMode.value;
        if (mode === 'custom') return;
        if (!dom.startDate.value) return;
        const start = new Date(dom.startDate.value);
        if (mode === 'week') {
            const end = new Date(start);
            end.setDate(end.getDate() + 6);
            dom.endDate.value = formatInputDate(end);
        } else if (mode === 'month') {
            const end = new Date(start);
            end.setMonth(end.getMonth() + 1, 0);
            dom.endDate.value = formatInputDate(end);
        }
    }

    dom.viewMode.addEventListener('change', adjustEndByMode);
    dom.startDate.addEventListener('change', adjustEndByMode);
    dom.workDateInput.addEventListener('change', () => {
        resetTimeTouched();
        autosetTimesForDemand('date-change');
    });
    dom.employeeSelect.addEventListener('change', () => {
        handleEmployeeChange();
        resetTimeTouched();
        autosetTimesForDemand('employee-change');
    });
    dom.skillSelect.addEventListener('change', () => {
        resetTimeTouched();
        autosetTimesForDemand('skill-change');
        maybeUpdateShiftName('skill-change');
    });
    dom.startTimeInput.addEventListener('change', () => {
        updateBreakHint();
        maybeUpdateShiftName('time-change');
    });
    dom.endTimeInput.addEventListener('change', () => {
        updateBreakHint();
        maybeUpdateShiftName('time-change');
    });
    dom.startTimeInput.addEventListener('input', () => {
        state.timeTouched.start = true;
        state.lastAutoShiftName = '';
    });
    dom.endTimeInput.addEventListener('input', () => {
        state.timeTouched.end = true;
        state.lastAutoShiftName = '';
    });
    dom.shiftNameInput.addEventListener('input', () => {
        state.lastAutoShiftName = '';
    });
    dom.breakAddBtn.addEventListener('click', () => addBreakRow());
    dom.breakSuggestBtn.addEventListener('click', () => {
        state.formBreaks = suggestBreakSet().map(br => ({ ...br, id: null }));
        renderBreakList();
    });
    dom.shiftTypeSelect.addEventListener('change', () => syncPlaceholderUI());

    dom.loadBtn.addEventListener('click', () => loadGrid());
    dom.discardBtn.addEventListener('click', () => {
        resetPending();
        loadGrid();
    });
    dom.saveBtn.addEventListener('click', saveChanges);
    dom.newBtn.addEventListener('click', handleCreate);
    dom.updateBtn.addEventListener('click', handleUpdate);
    dom.deleteBtn.addEventListener('click', handleDelete);

    function setMessage(text, type = 'success') {
        dom.messageBox.textContent = text;
        dom.messageBox.className = `message show ${type === 'error' ? 'error' : 'success'}`;
        if (text) {
            setTimeout(() => dom.messageBox.classList.remove('show'), 4500);
        }
    }

    async function loadGrid() {
        if (!dom.startDate.value || !dom.endDate.value) {
            setMessage('開始日と終了日を入力してください', 'error');
            return;
        }
        try {
            dom.metaInfo.textContent = '読み込み中...';
            const params = new URLSearchParams({
                start: dom.startDate.value,
                end: dom.endDate.value
            });
            const res = await fetch(`/api/schedule/grid?${params.toString()}`);
            const json = await res.json();
            if (!json.success) throw new Error(json.message || '取得に失敗しました');
            const data = json.data;
            state.days = buildDayList(data.startDate, data.endDate);
            state.employees = (data.employees || []).map(emp => ({
                ...emp,
                skills: Array.isArray(emp.skills) ? emp.skills : []
            }));
            populateEmployeeSelect();
            state.assignments.clear();
            (data.assignments || []).forEach(assign => {
                state.assignments.set(String(assign.id), {
                    ...assign,
                    clientId: String(assign.id),
                    isTemp: false
                });
            });
            rebuildSkillLookup();
            const selected = state.selectedAssignmentId ? state.assignments.get(state.selectedAssignmentId) : null;
            handleEmployeeChange(selected?.skillId ?? null, { preserveShiftName: true });
            resetPending();
            renderGrid();
            dom.metaInfo.textContent = `期間: ${data.startDate} 〜 ${data.endDate} / 従業員 ${state.employees.length} / シフト ${data.assignments.length}`;
            setMessage('グリッドを読み込みました', 'success');
        } catch (err) {
            console.error(err);
            setMessage(err.message, 'error');
            dom.metaInfo.textContent = '';
        }
    }

    function buildDayList(startStr, endStr) {
        const days = [];
        const start = new Date(startStr);
        const end = new Date(endStr);
        for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
            days.push(formatInputDate(d));
        }
        return days;
    }

    function populateEmployeeSelect() {
        const previous = dom.employeeSelect.value;
        dom.employeeSelect.innerHTML = '';
        state.employees.forEach(emp => {
            const option = document.createElement('option');
            option.value = emp.id;
            option.textContent = emp.name + (emp.role ? ` (${emp.role})` : '');
            dom.employeeSelect.appendChild(option);
        });
        if (previous && state.employees.some(emp => String(emp.id) === previous)) {
            dom.employeeSelect.value = previous;
        } else if (state.employees.length) {
            dom.employeeSelect.value = state.employees[0].id;
        }
    }

    function groupAssignments() {
        const grouped = new Map();
        state.assignments.forEach(assign => {
            const key = `${assign.employeeId}:${assign.workDate}`;
            if (!grouped.has(key)) grouped.set(key, []);
            grouped.get(key).push(assign);
        });
        grouped.forEach(list => list.sort((a, b) => (a.startTime || '').localeCompare(b.startTime || '')));
        return grouped;
    }

    function renderGrid() {
        const grouped = groupAssignments();
        const thead = dom.gridTable.querySelector('thead');
        const tbody = dom.gridTable.querySelector('tbody');
        thead.innerHTML = '';
        tbody.innerHTML = '';

        const headerRow = document.createElement('tr');
        const nameTh = document.createElement('th');
        nameTh.textContent = '従業員';
        headerRow.appendChild(nameTh);
        state.days.forEach(dateStr => {
            const th = document.createElement('th');
            const wd = weekdays[new Date(dateStr).getDay()];
            th.textContent = `${dateStr} (${wd})`;
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);

        state.employees.forEach(emp => {
            const tr = document.createElement('tr');
            const empTd = document.createElement('td');
            empTd.className = 'employee-cell';
            empTd.textContent = emp.name;
            tr.appendChild(empTd);
            state.days.forEach(dateStr => {
                const td = document.createElement('td');
                const key = `${emp.id}:${dateStr}`;
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.employeeId = emp.id;
                cell.dataset.date = dateStr;
                if (state.activeCellKey === key) cell.classList.add('active');
                cell.addEventListener('click', () => selectCell(cell));
                cell.addEventListener('dragover', evt => evt.preventDefault());
                cell.addEventListener('drop', evt => handleDrop(evt, cell));
                const assignments = grouped.get(key) || [];
                assignments.forEach(assign => {
                    const card = renderCard(assign);
                    cell.appendChild(card);
                });
                if (assignments.some(a => a.dirty)) {
                    cell.classList.add('dirty');
                }
                td.appendChild(cell);
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });
        updatePendingSummary();
    }

    function renderCard(assign) {
        const div = document.createElement('div');
        div.className = 'shift-card';
        div.draggable = true;
        div.dataset.assignmentId = assign.clientId;
        if (assign.isFree) div.classList.add('free');
        if (assign.isOff || assign.isLeave) div.classList.add('off');
        if (assign.dirty) div.classList.add('dirty');
        if (state.selectedAssignmentId === assign.clientId) {
            div.classList.add('selected');
        }
        div.textContent = buildCardLabel(assign);
        div.addEventListener('click', evt => {
            evt.stopPropagation();
            selectAssignment(assign.clientId);
        });
        div.addEventListener('dragstart', evt => {
            evt.dataTransfer.setData('text/plain', assign.clientId);
        });
        return div;
    }

    function buildCardLabel(assign) {
        const fmt = (time) => (time ? time.slice(0, 5) : '');
        if (assign.isLeave) {
            return '有給';
        }
        if (assign.isOff) {
            return '休日';
        }
        if (assign.isFree) {
            return '空き（待機）';
        }
        const baseName = (assign.shiftName && assign.shiftName.trim())
            || (assign.skillName && assign.skillName.trim())
            || 'シフト';
        const start = fmt(assign.startTime);
        const end = fmt(assign.endTime);
        const times = (start && end) ? `${start} - ${end}` : '';
        return times ? `${baseName} ${times}` : baseName;
    }

    function selectCell(cell) {
        state.activeCellKey = `${cell.dataset.employeeId}:${cell.dataset.date}`;
        dom.workDateInput.value = cell.dataset.date;
        dom.employeeSelect.value = cell.dataset.employeeId;
        handleEmployeeChange();
        state.lastAutoShiftName = '';
        state.formBreaks = [];
        renderBreakList();
        resetTimeTouched();
        autosetTimesForDemand('employee-change');
        highlightSelection();
    }

    function selectAssignment(clientId) {
        const assign = state.assignments.get(clientId);
        if (!assign) return;
        state.selectedAssignmentId = clientId;
        dom.employeeSelect.value = assign.employeeId;
        handleEmployeeChange(assign.skillId ?? null, { preserveShiftName: true });
        dom.workDateInput.value = assign.workDate;
        dom.shiftNameInput.value = assign.isFree ? '空き（待機）' : (assign.shiftName || '');
        state.lastAutoShiftName = '';
        dom.startTimeInput.value = assign.startTime || '';
        dom.endTimeInput.value = assign.endTime || '';
        state.formBreaks = hydrateBreaks(assign);
        renderBreakList();
        if (dom.shiftTypeSelect) {
            if (assign.isLeave) {
                dom.shiftTypeSelect.value = 'leave';
            } else if (assign.isOff) {
                dom.shiftTypeSelect.value = 'off';
            } else if (assign.isFree) {
                dom.shiftTypeSelect.value = 'free';
            } else {
                dom.shiftTypeSelect.value = 'normal';
            }
            syncPlaceholderUI();
        }
        resetTimeTouched();
        dom.selectionInfo.textContent = `選択中: ${assign.employeeName || ''} (${assign.workDate})`;
        highlightSelection();
    }

    function highlightSelection() {
        document.querySelectorAll('.grid-cell').forEach(cell => {
            const key = `${cell.dataset.employeeId}:${cell.dataset.date}`;
            cell.classList.toggle('active', key === state.activeCellKey);
        });
        document.querySelectorAll('.shift-card').forEach(card => {
            card.classList.toggle('selected', card.dataset.assignmentId === state.selectedAssignmentId);
        });
    }

    function collectFormValues() {
        const placeholderType = currentPlaceholderType();
        const startTime = effectiveTimeValue(dom.startTimeInput) || (placeholderType ? (PLACEHOLDER_LIMITS[placeholderType]?.start || PLACEHOLDER_LIMITS.default.start) : null);
        const endTime = effectiveTimeValue(dom.endTimeInput) || (placeholderType ? (PLACEHOLDER_LIMITS[placeholderType]?.end || PLACEHOLDER_LIMITS.default.end) : null);
        const skillId = placeholderType ? null : getSelectedSkillId();
        const payload = {
            employeeId: Number(dom.employeeSelect.value),
            workDate: dom.workDateInput.value,
            shiftName: dom.shiftNameInput.value.trim(),
            startTime,
            endTime,
            breakStart: null,
            breakEnd: null,
            breaks: placeholderType ? [] : state.formBreaks
                .filter(br => br.start && br.end)
                .map(br => ({
                    id: br.id || null,
                    type: br.type || 'SHORT',
                    start: br.start,
                    end: br.end,
                    autoGenerated: !!br.autoGenerated
                })),
            skillId,
            isFree: placeholderType === 'free',
            isOff: placeholderType === 'off',
            isLeave: placeholderType === 'leave'
        };
        const lunch = payload.breaks.find(br => br.type === 'LUNCH');
        if (lunch) {
            payload.breakStart = lunch.start;
            payload.breakEnd = lunch.end;
        }
        if (placeholderType === 'free') {
            payload.shiftName = 'FREE';
        }
        return payload;
    }

    function validateForm(payload) {
        const placeholderActive = Boolean(currentPlaceholderType());
        if (!payload.employeeId) throw new Error('従業員を選択してください');
        if (!payload.workDate) throw new Error('日付を入力してください');
        if (!payload.startTime || !payload.endTime) throw new Error('開始・終了時刻を入力してください');
        if (!placeholderActive && payload.startTime >= payload.endTime) throw new Error('終了時刻は開始より後にしてください');
        if (!placeholderActive) {
            payload.breaks.forEach(br => {
                if (!br.start || !br.end) throw new Error('休憩の開始・終了を入力してください');
                if (br.start >= br.end) throw new Error('休憩終了は開始より後にしてください');
                if (br.start < payload.startTime || br.end > payload.endTime) {
                    throw new Error('休憩は勤務時間内に設定してください');
                }
            });
        } else {
            payload.breaks = [];
            payload.breakStart = null;
            payload.breakEnd = null;
        }
    }

    function handleCreate() {
        try {
            const payload = collectFormValues();
            validateForm(payload);
            const clientId = `tmp-${++state.tempCounter}`;
            const employee = state.employees.find(e => Number(e.id) === payload.employeeId);
            state.pending.create.push({ ...payload, clientId });
            const assign = {
                ...payload,
                id: clientId,
                clientId,
                employeeName: employee ? employee.name : '',
                isTemp: true,
                dirty: true,
                breaks: payload.breaks || []
            };
            enrichAssignmentWithSkill(assign, payload.skillId ?? null);
            state.assignments.set(clientId, assign);
            state.activeCellKey = `${payload.employeeId}:${payload.workDate}`;
            selectAssignment(clientId);
            renderGrid();
            setMessage('新しいシフトを追加しました', 'success');
        } catch (err) {
            setMessage(err.message, 'error');
        }
    }

    function handleUpdate() {
        if (!state.selectedAssignmentId) {
            setMessage('更新するシフトを選択してください', 'error');
            return;
        }
        const assign = state.assignments.get(state.selectedAssignmentId);
        if (!assign) return;
        try {
            const payload = collectFormValues();
            validateForm(payload);
            applyPayloadToAssignment(assign, payload);
            renderGrid();
            setMessage('シフトを更新しました', 'success');
        } catch (err) {
            setMessage(err.message, 'error');
        }
    }

    function stageUpdatePayload(id, payload) {
        const normalized = {
            id: Number(id),
            employeeId: payload.employeeId,
            workDate: payload.workDate,
            startTime: payload.startTime,
            endTime: payload.endTime,
            breakStart: payload.breakStart,
            breakEnd: payload.breakEnd,
            breaks: payload.breaks,
            shiftName: payload.shiftName,
            skillId: payload.skillId,
            isFree: payload.isFree,
            isOff: payload.isOff,
            isLeave: payload.isLeave
        };
        const idx = state.pending.update.findIndex(p => p.id === normalized.id);
        if (idx >= 0) state.pending.update[idx] = normalized;
        else state.pending.update.push(normalized);
    }

    function updatePendingCreateEntry(clientId, payload) {
        const idx = state.pending.create.findIndex(p => p.clientId === clientId);
        if (idx >= 0) {
            state.pending.create[idx] = { ...payload, clientId };
        }
    }

    function applyPayloadToAssignment(assign, payload) {
        if (!assign) return;
        Object.assign(assign, payload, { dirty: true });
        enrichAssignmentWithSkill(assign, payload.skillId ?? null);
        if (assign.isTemp) {
            updatePendingCreateEntry(assign.clientId, payload);
        } else {
            stageUpdatePayload(assign.id, payload);
        }
        state.assignments.set(assign.clientId, assign);
        state.activeCellKey = `${payload.employeeId}:${payload.workDate}`;
        updatePendingSummary();
    }

    function normalizeBreakEntries(list) {
        return (list || []).map(br => ({
            type: (br.type || 'SHORT').toString(),
            start: normalizeTimeValue(br.start),
            end: normalizeTimeValue(br.end)
        }));
    }

    function breaksMatch(existing, incoming) {
        const a = normalizeBreakEntries(existing);
        const b = normalizeBreakEntries(incoming);
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) {
            if (a[i].type !== b[i].type || a[i].start !== b[i].start || a[i].end !== b[i].end) {
                return false;
            }
        }
        return true;
    }

    function assignmentMatchesPayload(assign, payload) {
        if (!assign || !payload) return false;
        const employeeSame = Number(assign.employeeId) === Number(payload.employeeId);
        const dateSame = (assign.workDate || '') === (payload.workDate || '');
        const startSame = normalizeTimeValue(assign.startTime) === normalizeTimeValue(payload.startTime);
        const endSame = normalizeTimeValue(assign.endTime) === normalizeTimeValue(payload.endTime);
        const shiftSame = normalizeShiftName(assign.shiftName) === normalizeShiftName(payload.shiftName);
        const skillSame = (assign.skillId == null ? null : Number(assign.skillId)) === (payload.skillId == null ? null : Number(payload.skillId));
        const breakStartSame = normalizeTimeValue(assign.breakStart) === normalizeTimeValue(payload.breakStart);
        const breakEndSame = normalizeTimeValue(assign.breakEnd) === normalizeTimeValue(payload.breakEnd);
        const breaksSame = breaksMatch(assign.breaks, payload.breaks);
        const flagsSame = Boolean(assign.isFree) === Boolean(payload.isFree)
            && Boolean(assign.isOff) === Boolean(payload.isOff)
            && Boolean(assign.isLeave) === Boolean(payload.isLeave);
        return employeeSame && dateSame && startSame && endSame && shiftSame && skillSame && breakStartSame && breakEndSame && breaksSame && flagsSame;
    }

    function ensureFormSyncedWithSelection(options = {}) {
        const { render = false } = options;
        if (!state.selectedAssignmentId) return false;
        const assign = state.assignments.get(state.selectedAssignmentId);
        if (!assign) return false;
        const payload = collectFormValues();
        if (assignmentMatchesPayload(assign, payload)) {
            return false;
        }
        validateForm(payload);
        applyPayloadToAssignment(assign, payload);
        if (render) {
            renderGrid();
        }
        return true;
    }

    function handleDelete() {
        if (!state.selectedAssignmentId) {
            setMessage('削除するシフトを選択してください', 'error');
            return;
        }
        const assign = state.assignments.get(state.selectedAssignmentId);
        if (!assign) return;
        if (assign.isTemp) {
            state.pending.create = state.pending.create.filter(p => p.clientId !== assign.clientId);
        } else {
            if (!state.pending.delete.includes(assign.id)) {
                state.pending.delete.push(assign.id);
            }
            state.pending.update = state.pending.update.filter(p => p.id !== assign.id);
        }
        state.assignments.delete(assign.clientId);
        state.selectedAssignmentId = null;
        state.selectionInfo.textContent = '未選択';
        renderGrid();
        setMessage('シフトを削除に追加しました', 'success');
    }

    function handleDrop(evt, cell) {
        evt.preventDefault();
        const assignmentId = evt.dataTransfer.getData('text/plain');
        const assign = state.assignments.get(assignmentId);
        if (!assign) return;
        const payload = {
            employeeId: Number(cell.dataset.employeeId),
            workDate: cell.dataset.date,
            shiftName: assign.shiftName || '',
            startTime: assign.startTime,
            endTime: assign.endTime,
            breakStart: assign.breakStart || null,
            breakEnd: assign.breakEnd || null,
            breaks: Array.isArray(assign.breaks) ? assign.breaks.map(b => ({ ...b })) : [],
            skillId: assign.skillId ?? null,
            isFree: assign.isFree,
            isOff: assign.isOff,
            isLeave: assign.isLeave
        };
        applyPayloadToAssignment(assign, payload);
        renderGrid();
    }

    async function saveChanges() {
        try {
            ensureFormSyncedWithSelection({ render: true });
        } catch (err) {
            setMessage(err.message, 'error');
            return;
        }
        if (!hasPendingChanges()) {
            setMessage('保存する変更がありません', 'error');
            return;
        }
        try {
            dom.saveBtn.disabled = true;
            const body = {
                create: state.pending.create.map(({ clientId, ...rest }) => rest),
                update: state.pending.update,
                delete: state.pending.delete
            };
            const res = await fetch('/api/schedule/grid/bulk', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            const json = await res.json();
            if (!json.success) throw new Error(json.message || '保存に失敗しました');
            setMessage('変更を保存しました', 'success');
            resetPending();
            await loadGrid();
        } catch (err) {
            console.error(err);
            setMessage(err.message, 'error');
        } finally {
            dom.saveBtn.disabled = false;
        }
    }

    function resetPending() {
        state.pending = { create: [], update: [], delete: [] };
        state.selectedAssignmentId = null;
        state.clipboard = null;
        updatePendingSummary();
    }

    function updatePendingSummary() {
        const total = state.pending.create.length + state.pending.update.length + state.pending.delete.length;
        dom.pendingInfo.textContent = `未保存の変更: ${total} 件 (追加 ${state.pending.create.length} / 更新 ${state.pending.update.length} / 削除 ${state.pending.delete.length})`;
    }

    function hasPendingChanges() {
        return state.pending.create.length > 0
            || state.pending.update.length > 0
            || state.pending.delete.length > 0;
    }

    document.addEventListener('keydown', evt => {
        if (!evt.ctrlKey) return;
        if (evt.key === 'c' && state.selectedAssignmentId) {
            const source = state.assignments.get(state.selectedAssignmentId);
            state.clipboard = {
                ...source,
                breaks: Array.isArray(source.breaks) ? source.breaks.map(b => ({ ...b })) : []
            };
            setMessage('コピーしました', 'success');
        }
        if (evt.key === 'v' && state.clipboard && dom.employeeSelect.value && dom.workDateInput.value) {
            const payload = {
                employeeId: Number(dom.employeeSelect.value),
                workDate: dom.workDateInput.value,
                shiftName: state.clipboard.shiftName,
                startTime: state.clipboard.startTime,
                endTime: state.clipboard.endTime,
                breakStart: state.clipboard.breakStart || null,
                breakEnd: state.clipboard.breakEnd || null,
                breaks: Array.isArray(state.clipboard.breaks) ? state.clipboard.breaks.map(b => ({ ...b, id: null })) : [],
                skillId: state.clipboard.skillId ?? null,
                isFree: state.clipboard.isFree,
                isOff: state.clipboard.isOff,
                isLeave: state.clipboard.isLeave
            };
            const clientId = `tmp-${++state.tempCounter}`;
            state.pending.create.push({ ...payload, clientId });
            const cloned = { ...payload, id: clientId, clientId, isTemp: true, dirty: true };
            enrichAssignmentWithSkill(cloned, payload.skillId ?? null);
            state.assignments.set(clientId, cloned);
            renderGrid();
            setMessage('貼り付けました', 'success');
        }
    });

    initDates();
    adjustEndByMode();
    syncPlaceholderUI();
    await fetchBreakSettings();
    updateBreakHint();
    window.reloadScheduleGrid = () => loadGrid();
    loadGrid();
})();
</script>
</body>
</html>
